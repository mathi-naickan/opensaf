#
#      -*- OpenSAF  -*-
#
# (C) Copyright 2008 The OpenSAF Foundation
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
# under the GNU Lesser General Public License Version 2.1, February 1999.
# The complete license can be accessed from the following location:
# http://opensource.org/licenses/lgpl-license.php
# See the Copying file included with the OpenSAF distribution for full
# licensing terms.
#
# Author(s): Ericsson AB
#

GENERAL
This directory (services/ntfsv) contains an implementation of the SAF 
Notification Service version A.01.01.

Application programmers intending to interface with ntfsv should primarily read
the document "OpenSAF NTF Service Release 4.2 Programmer's Reference" and of
course the NTF standard (SAI-AIS-NTF-A.01.01).

This document provides an overview of the design and internals of the ntfsv. 
It is intended for maintainers or trouble-shooters of the ntfsv in OpenSAF.
Familiarity with the NTF standard is obviously also helpful in understanding
this document. 

The NTF service is implemented as a server process executing on the controllers
using a 2N redundancy model. Message based check pointing is used to synchronize
the two server instances. The NTF service follows the OpenSAF Service server 
concept (see OpenSAF Overview User's Guide). Process structure:
     * NTF Server (ntfs)
     * The application processes linked with the NTF library (ntfa)
               
The NTF service was originally cloned from the lgsv service. The server part 
consists of one c++ part that has been ported from an earlier implementation. 
Parts of the library implementations and the base for the 'ntfsend' and 
'ntfsubscribe' commands are also taken from an earlier implementation.

Only a limited version of the Reader API is implemented which reads from a 
cache of configurable size, default is 10000 notification.

An extra feature called imcn (Information Model Change Notification) is also
implemented. This is a feature for sending special notifications when objects
are created or deleted and when attributes are changed.
This is an OpenSAF feature that is not a part of the AIS standard.
For more information see README file in the ntfimcnd directory.

Support for long DNs (4.5)
==========================
https://sourceforge.net/p/opensaf/tickets/873/
This enhancement ticket #873 adds support for long DNs in NTF Service, that is part of supporting 
long DNs in OpenSAF tracked by ticket #191.

The implementation of #873 will use the SaNameT tunneling primitives to allow any SaNameT elements
in a notification longer than 255 bytes, which is currently applicable for notificationObject(s), 
notifyingObject(s) and any SaNtfValue elements as SA_NTF_VALUE_LDAP_NAME.

In order to utilize the long DNs support in NTF, the NTF client (producer, consumer) must also use 
the SaNameT tunneling primitives provided by ticket #191 to manipulate SaNameT elements, and the 
environment variable SA_ENABLE_EXTENDED_NAMES is set to "1" in the NTF client process. Otherwise, 
the producer will fail to send long DNs notification with returned code SA_AIS_ERR_INVALID_PARAM,
and any long DNs notification will be invisible to the consumer.

The support long DNs in IMM (#886) must also be enabled so that the NTF IMCN can send notification 
when long DNs objects are created, deleted, or their attributes are changed. 

Since LOG service has not (yet) supported long DNs in OpenSAF 4.5, so any Alarm Log having either 
notificationObject or notifyingObject as long DN will be truncated to at most 255 bytes length.

Using SA_NTF_VALUE_LDAP_NAME as long DNs, please see "IMPLEMENTATION NOTES"

DEPENDENCIES
ntfsv depends of the following other OpenSAF services:
- MBCSV
- MDS
- BASE
- logtrace

DIRECTORY STRUCTURE

osaf/libs/common/ntfsv/include/	Common header files used by both ntfa and ntfs,
                                implementation used by both server and library.
osaf/libs/agents/saf/ntfa	    ntf library implementation
osaf/services/saf/ntfsv/ntfs	    ntf server
osaf/services/saf/ntfsv/ntfimcnd    ntfimcn deamon
osaf/tools/safntf/ntfsend	    ntfsend ntfsubscribe command
osaf/tools/safntf/ntfsubscribe	    ntfsubscribe command
osaf/tools/safntf/ntfread	    ntfread command
osaf/libs/saf/libSaNtf		    NTF library staging
tests/ntfsv			    Test suite

MAIN FILES
ntfs:
-NtfCom.h    defines the interface between NtfAdmin part and the C communication
              layer (encode/decode, mbcsv, mds)
-NtfAdmin.hh main object in the c++ structure.

ntfa:
-ntfa_api.c - implementation of interface saNtf.h

DATA STRUCTURES
NTFS uses the following data structures:
-Control block. Statically allocated, one instance. Access through a global
pointer variable.

-NtfAdmin
The Admin part is responsible for handling information about clients, 
subscriptions, filters and notifications. For redundancy reasons all information
are sent to the standby node by mbcsv. The information is organized to objects 
in a tree and each object has an identifier.

The identifiers:
* clientId is a node-wide unique id that is assigned by NTF
* subscriptionId is a client-wide unique id that is assigned by the NTFa
* notificationId is a cluster-wide unique id that is assigned by NTF
* filterType - is an id based on the notificationType

Each object in the NtfAdmin tree holds information about its underlying object
in a map. Maps are STL (Standard Template Library) containers that contain 
unique key/value pairs, the key is always an identifier, and the value is always
a pointer to the object.
This means that the Admin object has a nodeMap where each entry contains
a nodeId and a pointer to the appropriate node object.

The maps are:
* clientMap is located in the Admin object and holds information about
  all clients.
* readerMap is located in the Client object. For each reader initialize a new 
  NtfReader object is created with smart pointer references to the cached notifications
  that fits the provided filter and search criteria.
* subscriptionMap is located in the Client object and holds information
  about all subscriptions that the certain client has
* filterMap is located in the Subscription object and holds information
  about all filters that belongs to the certain subscription
* notificationMap is located in the Admin object and holds information
  about all active notifications. Active notification in this context 
  means a notification that was not yet delivered to all matching subscriptions

Other objects handled by NtfAdmin:
* logger - Admin holds a NtfLogger object which logs incoming notifications and 
  saves a cache of the 10000 latest alarm notification in a STL deque container

NTFA uses the following data structures:
- Control block. Statically allocated, one instance per library. Access
through a global variable. The control block contains the head of a linked
list with client descriptors.

- Client descriptor. Dynamically allocated. One instance per call to
saNtfInitialize(). Contains callback pointers, handles and the head of a
linked list with descriptors for notifications, filters and readers.
- subscriberNoList struct mapping subscription Id to client handle to be able
to send unsubscribe to server. 

IMPLEMENTATION NOTES

(1) Using SA_NTF_VALUE_LDAP_NAME as long DNs in saNtfPtrValAllocate() in OpenSAF 4.5
------------------------------------------------------------------------------------
SaAisErrorT saNtfPtrValAllocate(SaNtfNotificationHandleT handle,
								SaUint16T dataSize, 
								void **dataPtr, 
								SaNtfValueT *value)
	
Provided that producer has adapted long DNs, and prior than #873 the saNTfPtrValAllocate has
normally being used as the way below:

	saNtfPtrValAllocate(handle, sizeof(SaNameT)+1, (void**)&destPtr, &value);
	memcpy(destPtr, &name, sizeof(name)); /* which @name as SaNameT, @destPtr as char* */

Due to the long DNs string is not fully aligned in @name, so the above codes will make the 
string in @name (as long DN) truncated to fix the size of allocated memory. In OpenSAF 4.5,
if a NTF producer has supported long DNs, it's recommended to use the SaNameT tunneling API
to pass SaNameT into @destPtr as below:
	
	if (saNtfPtrValAllocate(handle, 
						strlen(saAisNameBorrow(&name) + 3,
						(void**)&destPtr, &value) == SA_AIS_OK) {
		saAisNameLend(saAisNameBorrow(&name), (SaNameT*)destPtr);
	}

This should work for both short and long DNs

(2) Using SA_NTF_VALUE_LDAP_NAME as long DNs in saNtfPtrValGet() in OpenSAF 4.5
-------------------------------------------------------------------------------
SaAisErrorT saNtfPtrValGet(SaNtfNotificationHandleT handle,
							const SaNtfValueT *value, 
							void **dataPtr, 
							SaUint16T *dataSize)
							
Provided that consumer has adapted long DNs, otherwise the saNtfPtrValGet will return error code
SA_AIS_ERR_NAME_TOO_LONG if the @value is type of SA_NTF_VALUE_LDAP_NAME as a long DN. In OpenSAF
4.5, if a NTF consumer has supported long DNs, it's recommended to use the SaNameT tunneling API
retrieve SaNameT via @dataPtr as below:

	if (saNtfPtrValGet(handle, &value, &destPtr, &size) == SA_AIS_OK) { /* destPtr as char* */
		saAisNameLend((SaConstStringT)destPtr + 2, &name); /* name as SaNameT */
	}

This should work for both short and long DNs
	
CONFIGURATION
Implementation defined configuration is done using a configuration
file with environment variables. This config file is typically:

/etc/opensaf/ntfd.conf

The NTF server start script sources the configuration file before it starts
the NTF server. So any change in this file will require a restart of the NTF
server which implies OpenSAF on that node.

The following environment variable is optional:

NTFSV_ENV_CACHE_SIZE

The size of the notification cache in the NTF server processes running on the Controller nodes.
The default value is 10000 notification.


for debug see DEBUG.

COMMAND LINE INTERFACE
The 'ntfsend'/'ntfsubscribe'/'ntfread' commands can be used to send/receive/read notifications.
Please see the on line help for more information.

DEBUG

Ntf server traces are by default disabled. To enable/disable ntf server traces 
in a running system, send signal USR2 to the ntfd process. Every time the 
trace state is toggled. Example:

	$ pkill -USR2 opensaf_ntfd

Traces are written to the file:

	$pklogdir/osafntfd.log

To enable traces from the very start of the ntf server, uncomment the line:

        #args="--tracemask=0xffffffff"

in ntfd.conf (see CONFIGURATION above) and restart the cluster.

For fatal errors syslog is used.

To enable traces in the NTF library, export the variable NTFSV_TRACE_PATHNAME
with a valid pathname before starting the application using the NTF library.

For example:

$ export NTFSV_TRACE_PATHNAME=/tmp/ntf.trace
$ ntfsend
$ cat /tmp/ntf.trace


TEST

Currently a simple unit test can be found in 'tests/ntfsv'. The test suite
is built by the main make system and is either install by 'make install' or by
installing the tools rpm.


ITEMS TO BE DONE:
-----------------
Cleanup:
-remove trace
-review/remove TODO statements in code
-restructure lib (ntfa_api.c)

Make NTF to fully A.01.01 compliant 
===================================
Internationalization
-saNtfLocalizedMessageGet
-saNtfLocalizedMessageFree

Reader API
- read from SAFLog records

CONTRIBUTORS/MAINTAINERS
Arne Eriksson <Arne.R.Eriksson@ericsson.com>
Hans Feldt

